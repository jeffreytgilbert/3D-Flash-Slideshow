package  {		import flash.display.MovieClip;	import flash.geom.PerspectiveProjection;	import flash.display.Shape;	import com.greensock.TweenLite;	import flash.geom.Point;	import com.greensock.easing.Circ;	import com.greensock.easing.Linear;	import com.greensock.easing.Elastic;	import flash.display.Sprite;	import com.greensock.easing.Bounce;	import com.greensock.easing.Quad;	import flash.events.Event;	import flash.display.BitmapData;	import flash.display.Bitmap;	import flash.geom.Matrix;		/*		// Example usage. 		_thumbnailContainer.visible=false;		var _cube:CubeTransition = new CubeTransition(bmp,bmp2,bmp.width,bmp.height,400);	_cube.x = stage.stageWidth / 2;	_cube.y = stage.stageHeight / 2;	_cube.addEventListener(CubeTransition.CUBE_TRANSITION_FINISHED,_cube.transitionLeft);	addChild(_cube);	_cube.transitionLeft();	*/		public class CubeTransition extends Sprite {				private var _currentPane:Bitmap = new Bitmap();		private var _newPane:Bitmap = new Bitmap();				private var _targetWidth:Number;		private var _targetHeight:Number;		private var _halfWidth:Number;		private var _halfHeight:Number;		private var _targetDepth:Number;		public static const CUBE_TRANSITION_STARTED:String = 'cubeTransitionStarted';		public static const CUBE_TRANSITION_FINISHED:String = 'cubeTransitionFinished';		//		public var s:Shape = new Shape();//		public var so:Shape = new Shape();//		public var sc:Shape = new Shape();		public function CubeTransition(currentImage:Bitmap, newImage:Bitmap, _width, _height, _zDepth) {			// constructor code						_targetWidth = _width;			_targetHeight = _height;			_targetDepth = _zDepth;			_halfHeight = (_targetHeight/2);			_halfWidth  = (_targetWidth/2);						_currentPane = currentImage;			_newPane = newImage;/*			// Colored blocks to show off where things are in relation to the cube effect			addChild(s);			BitmapUtils.colorToShape(0xff00ff,s,_width,_height);			addChild(so);			BitmapUtils.colorToShape(0x0000ff,so,20,20);			addChild(sc);			BitmapUtils.colorToShape(0xff0000,sc,20,20);						s.x=-_halfWidth;			s.y=-_halfHeight;			s.z=-_halfWidth;			so.x=0;			so.y=0;			so.z=0;						sc.x=0;			sc.y=-_halfHeight;			sc.z=-_halfWidth;*/						addChild(_newPane);			addChild(_currentPane);		}				public function transitionLeft(evt:Event=null):void{			dispatchEvent(new Event(CubeTransition.CUBE_TRANSITION_STARTED,true,true));			if(getChildIndex(_currentPane) < getChildIndex(_newPane)){ swapDepths(); }			// draw face 1			_currentPane.rotationY=0;			_currentPane.x = -_halfWidth;			_currentPane.y = -_halfHeight;			_currentPane.z = -_halfWidth;			// draw face 2			_newPane.rotationY = -90;			_newPane.x = _halfWidth;			_newPane.y = -_halfHeight;			_newPane.z = -_halfWidth;			z=_targetDepth-50;			rotationY=0;			TweenLite.delayedCall(.25, swapDepths);			TweenLite.to(this, .5, {				rotationY:45, z:_targetDepth, ease:Quad.easeIn, onComplete:secondHalfLeft			});		}				private function secondHalfLeft():void{			TweenLite.to(this, .5, { 				rotationY:90, z:_targetDepth-50, ease:Quad.easeOut, onComplete:transitionComplete 			});		}				public function transitionRight(evt:Event=null):void{			dispatchEvent(new Event(CubeTransition.CUBE_TRANSITION_STARTED,true,true));			if(getChildIndex(_currentPane) < getChildIndex(_newPane)){ swapDepths(); }			// draw face 1			_currentPane.rotationY=0;			_currentPane.x = -_halfWidth;			_currentPane.y = -_halfHeight;			_currentPane.z = -_halfWidth;			// draw face 2			_newPane.rotationY = 90;			_newPane.x = -_halfWidth;			_newPane.y = -_halfHeight;			_newPane.z = _halfWidth;						z=_targetDepth-50;			rotationY=0;			TweenLite.delayedCall(.25, swapDepths);			TweenLite.to(this, .5, {				rotationY:-45, z:_targetDepth, ease:Quad.easeIn, onComplete:secondHalfRight			});		}				public function centered3dSpriteToBitmap(sprite:*, w, h):Bitmap{			var myBitmap:BitmapData = new BitmapData(w+1, h+1, true, 0x00000000);			var matrix:Matrix = new Matrix();			matrix.scale(1,1);			matrix.translate( (w/2), (h/2) );			myBitmap.draw(sprite, matrix);			return new Bitmap(myBitmap);		}				private function secondHalfRight():void{			TweenLite.to(this, .5, { 				rotationY:-90, z:_targetDepth-50, ease:Quad.easeOut, onComplete:transitionComplete 			});		}				private function transitionComplete():void{			dispatchEvent(new Event(CubeTransition.CUBE_TRANSITION_FINISHED,true,true));		}				private function swapDepths():void{			swapChildren(_currentPane,_newPane);		}	}}