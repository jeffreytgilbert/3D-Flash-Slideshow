/*** Drag by Grant Skinner. Jun 27, 2008* Visit www.gskinner.com/blog for documentation, updates and more free code.*** Copyright (c) 2011 Grant Skinner* * Permission is hereby granted, free of charge, to any person* obtaining a copy of this software and associated documentation* files (the "Software"), to deal in the Software without* restriction, including without limitation the rights to use,* copy, modify, merge, publish, distribute, sublicense, and/or sell* copies of the Software, and to permit persons to whom the* Software is furnished to do so, subject to the following* conditions:* * The above copyright notice and this permission notice shall be* included in all copies or substantial portions of the Software.* * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES* OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT* HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR* OTHER DEALINGS IN THE SOFTWARE.**/package com.gskinner.ui {		import flash.display.InteractiveObject;	import flash.geom.Rectangle;	import flash.events.MouseEvent;		public class Drag {				// Constants:		static public const START:String = "start";		static public const STOP:String = "stop";		static public const DRAG:String = "drag";				// Public Properties:		// Private Properties:			// Initialization:		public function Drag() { }			// Public Methods:		// Protected Methods:				static public var dragProps:DragProps;				static public function start(target:InteractiveObject, constraints:Rectangle=null, callback:Function=null):void {			if (dragProps) { stop(); }			target.stage.addEventListener(MouseEvent.MOUSE_MOVE,doDrag);			target.stage.addEventListener(MouseEvent.MOUSE_UP,endDrag);			dragProps = new DragProps(target, constraints, callback);		}				static public function stop():void {			if (dragProps == null) { return; }			var target:InteractiveObject = dragProps.target as InteractiveObject;			target.stage.removeEventListener(MouseEvent.MOUSE_MOVE,doDrag);			target.stage.removeEventListener(MouseEvent.MOUSE_UP,endDrag);			target.stage.mouseChildren = true;			var callback:Function = dragProps.callback;			dragProps = null;			if (callback != null) { callback(target,STOP); }		}				static private function doDrag(evt:MouseEvent):void {			var target:InteractiveObject = dragProps.target as InteractiveObject;			var callback:Function = dragProps.callback;			if (!dragProps.dragInited) {				if (Math.sqrt(Math.pow(target.parent.mouseX-dragProps.originalX,2)+Math.pow(target.parent.mouseY-dragProps.originalY,2)) < 10) { return; }				dragProps.dragInited = true;				target.stage.mouseChildren = false;				if (callback != null) { callback(target,START); }			}			if (callback != null) { callback(target,DRAG); }			if (dragProps.constraints) {				var rect:Rectangle = dragProps.constraints as Rectangle;				target.x = Math.min(rect.x+rect.width,Math.max(rect.x,target.parent.mouseX-dragProps.offsetX));				target.y = Math.min(rect.y+rect.height,Math.max(rect.y,target.parent.mouseY-dragProps.offsetY));			} else {				target.x = target.parent.mouseX-dragProps.offsetX;				target.y = target.parent.mouseY-dragProps.offsetY;			}		}				static private function endDrag(evt:MouseEvent):void {			stop();		}	}	}class DragProps {	import flash.display.InteractiveObject;	import flash.geom.Rectangle;		public var target:InteractiveObject;	public var offsetX:Number;	public var offsetY:Number;	public var originalX:Number;	public var originalY:Number;	public var constraints:Rectangle;	public var callback:Function;	public var dragInited:Boolean=false;		public function DragProps(target:InteractiveObject, constraints:Rectangle=null, callback:Function=null):void {		this.target = target;		this.offsetX = target.mouseX;		this.offsetY = target.mouseY;		this.originalX = target.parent.mouseX;		this.originalY = target.parent.mouseY;		this.constraints = constraints;		this.callback = callback;	}}