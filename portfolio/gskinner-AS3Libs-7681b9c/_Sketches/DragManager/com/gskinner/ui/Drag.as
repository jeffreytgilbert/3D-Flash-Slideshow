/*** Drag by Grant Skinner. Jun 27, 2008* Visit www.gskinner.com/blog for documentation, updates and more free code.*** Copyright (c) 2011 Grant Skinner* * Permission is hereby granted, free of charge, to any person* obtaining a copy of this software and associated documentation* files (the "Software"), to deal in the Software without* restriction, including without limitation the rights to use,* copy, modify, merge, publish, distribute, sublicense, and/or sell* copies of the Software, and to permit persons to whom the* Software is furnished to do so, subject to the following* conditions:* * The above copyright notice and this permission notice shall be* included in all copies or substantial portions of the Software.* * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES* OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT* HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR* OTHER DEALINGS IN THE SOFTWARE.**/package com.gskinner.ui {		import flash.display.InteractiveObject;	import flash.geom.Rectangle;	import flash.events.MouseEvent;	import flash.events.EventDispatcher;	import flash.events.Event;		public class Drag extends EventDispatcher {			// Constants:		public static const START:String = "start";		public static const STOP:String = "stop";		public static const INIT:String = "init";		public static const DRAG:String = "drag";			// Public Properties:		public var constraints:Rectangle;		public var dragTolerance:Number=8;						public var _offsetX:Number = NaN;		public var _offsetY:Number = NaN;		public var _originalX:Number = NaN;		public var _originalY:Number = NaN;		public var _originalMouseX:Number = NaN;		public var _originalMouseY:Number = NaN;			// Private Properties:		protected var _target:InteractiveObject;		protected var _enabled:Boolean;		protected var _active:Boolean = false;		protected var dragInited:Boolean=false;				// Initialization:		public function Drag(target:InteractiveObject, constraints:Rectangle=null, enabled:Boolean=true) {			this.target = target;			this.constraints = constraints;			this.enabled = enabled;		}		// Public Methods:		public function get target():InteractiveObject {			return _target;		}		public function set target(value:InteractiveObject):void {			if (_active) { stop(); }			_target = value;			enabled = _enabled;		}				public function get enabled():Boolean {			return _enabled;		}		public function set enabled(value:Boolean):void {			_enabled = value;			if (_target && _enabled) {				_target.addEventListener(MouseEvent.MOUSE_DOWN, handleMouseDown);			} else {				_target.removeEventListener(MouseEvent.MOUSE_DOWN, handleMouseDown);			}		}				public function get offsetX():Number { return _offsetX; }		public function get offsetY():Number { return _offsetY; }		public function get originalX():Number { return _originalX; }		public function get originalY():Number { return _originalY; }		public function get originalMouseX():Number { return _originalMouseX; }		public function get originalMouseY():Number { return _originalMouseY; }				public function start():void {			if (_active) { stop(); }			if (_target.stage == null) { return; }			_active = true;			_target.stage.addEventListener(MouseEvent.MOUSE_MOVE,doDrag,false,0,true);			_target.stage.addEventListener(MouseEvent.MOUSE_UP,endDrag,false,0,true);			_offsetX = target.mouseX;			_offsetY = target.mouseY;			_originalX = target.x;			_originalY = target.y;			_originalMouseX = target.parent.mouseX;			_originalMouseY = target.parent.mouseY;			dispatchEvent(new Event(START));			if (dragTolerance == -1) {				initDrag();			}		}				public function stop():void {			if (!_active) { return; }			dragInited = false;			_target.stage.removeEventListener(MouseEvent.MOUSE_MOVE,doDrag);			_target.stage.removeEventListener(MouseEvent.MOUSE_UP,endDrag);			_target.mouseEnabled = true;			dispatchEvent(new Event(STOP));			_offsetX = _offsetY = _originalX = _originalY = _originalMouseX = _originalMouseY = NaN;		}					// Protected Methods:		protected function handleMouseDown(evt:MouseEvent):void {			start();		}				protected function doDrag(evt:MouseEvent):void {			if (!dragInited) {				if (Math.sqrt(Math.pow(target.parent.mouseX-_originalMouseX,2)+Math.pow(target.parent.mouseY-_originalMouseY,2)) < dragTolerance) { return; }				initDrag();			}						if (constraints) {				var rect:Rectangle = constraints as Rectangle;				_target.x = Math.min(rect.x+rect.width,Math.max(rect.x,_target.parent.mouseX-_offsetX));				_target.y = Math.min(rect.y+rect.height,Math.max(rect.y,_target.parent.mouseY-_offsetY));			} else {				_target.x = _target.parent.mouseX-_offsetX;				_target.y = _target.parent.mouseY-_offsetY;			}			dispatchEvent(new Event(DRAG));		}				protected function initDrag():void {			dragInited = true;			_target.mouseEnabled = false;			dispatchEvent(new Event(INIT));		}				protected function endDrag(evt:MouseEvent):void {			stop();		}	}	}