/*** HeatMap by Grant Skinner. Aug 1, 2007* Visit www.gskinner.com/blog for documentation, updates and more free code.*** Copyright (c) 2007 Grant Skinner* * Permission is hereby granted, free of charge, to any person* obtaining a copy of this software and associated documentation* files (the "Software"), to deal in the Software without* restriction, including without limitation the rights to use,* copy, modify, merge, publish, distribute, sublicense, and/or sell* copies of the Software, and to permit persons to whom the* Software is furnished to do so, subject to the following* conditions:* * The above copyright notice and this permission notice shall be* included in all copies or substantial portions of the Software.* * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES* OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT* HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR* OTHER DEALINGS IN THE SOFTWARE.**/package com.gskinner.misc {		import flash.display.BitmapData;	import flash.display.Sprite;	import flash.geom.Point;	import flash.filters.BlurFilter;	import flash.display.Shape;	import flash.geom.Matrix;	import flash.display.GradientType;		public class HeatMap {				private var mapBmpd:BitmapData;		private var _width:uint;		private var _height:uint;		private var _mapScale:Number;		private var _pinScale:Number;		private var dots:Array;		private var canvas:Sprite;		private var point:Point;		private var blurF:BlurFilter;		private var paletteMaps:Object;		private var _xOffset:Number;		private var _yOffset:Number;				public function HeatMap(width:uint,height:uint,mapScale:Number=1,pinScale:Number=1,xOffset:Number=0,yOffset=0) {			_width = width;			_height = height;			_mapScale = mapScale;			_pinScale = pinScale;			_xOffset = xOffset;			_yOffset = yOffset;			dots = [];			canvas = new Sprite();			point = new Point();			paletteMaps = generatePaletteMaps([0x00000000,0x00FFFFFF,0x11002266,0x330077CC,0x9900CC00,0xCCFFFF00,0xFFFF9900,0xFFFF0000,0xFFFF0000],											  [0         ,40        ,64        ,96        ,128       ,172       ,224       ,246       ,256       ]);		}				public function get width():uint {			return _width;		}		public function set width(value:uint):void {			_width = value;		}				public function get height():uint {			return _height;		}		public function set height(value:uint):void {			_height = value;		}				public function get mapScale():Number {			return _mapScale;		}		public function set mapScale(value:Number):void {			_mapScale = value;		}				public function get pinScale():Number {			return _pinScale;		}		public function set pinScale(value:Number):void {			_pinScale = value;		}				public function get xOffset():Number {			return _xOffset;		}		public function set xOffset(value:Number):void {			_xOffset = value;		}				public function get yOffset():Number {			return _yOffset;		}		public function set yOffset(value:Number):void {			_yOffset = value;		}				public function getHeatMap(data:Array):BitmapData {			updateMapBmpd();			updateCanvas(data);			updateHeatMap();			return mapBmpd		}				protected function updateMapBmpd():void {			var bmpw:uint = Math.ceil(_width*_mapScale);			var bmph:uint = Math.ceil(_height*_mapScale);			if (mapBmpd == null || mapBmpd.width != bmpw || mapBmpd.height != bmph) {				if (mapBmpd) { mapBmpd.dispose(); }				mapBmpd = new BitmapData(bmpw,bmph,true,0);			}		}				protected function updateCanvas(data:Array):void {			var pinSc:Number = _mapScale*_pinScale;			var xOff:Number = _xOffset;			var yOff:Number = _yOffset;						var l:uint = data.length;			var dot:Shape;						while (dots.length < l) {				dot = getNewDot();				canvas.addChild(dot);				dots.push(dot);			}			for (var i:uint=0; i<l; i++) {				var pt:Object = data[i];				dot = dots[i] as Shape;				dot.x = (pt.x+xOff)*_mapScale;				dot.y = (pt.y+yOff)*_mapScale;				dot.visible = true;				dot.scaleX = dot.scaleY = pinSc;			}						while (++i < dots.length) {				dots[i].visible = false;			}		}				protected function updateHeatMap():void {			mapBmpd.fillRect(mapBmpd.rect,0xFF000000);			mapBmpd.draw(canvas);			mapBmpd.applyFilter(mapBmpd,mapBmpd.rect,point,new BlurFilter(32*_mapScale,32*_mapScale,2));			mapBmpd.paletteMap(mapBmpd,mapBmpd.rect,point,paletteMaps.r,paletteMaps.g,paletteMaps.b,paletteMaps.a);		}				public function getNewDot():Shape {			var dot:Shape = new Shape();			var mtx:Matrix = new Matrix();			mtx.createGradientBox(32,32,0,-16,-16);			dot.graphics.beginGradientFill(GradientType.RADIAL,[0x333333,0x000000],[255,255],[0,255],mtx);			dot.graphics.drawCircle(0,0,16);			dot.graphics.endFill();			dot.blendMode = "add";			return dot;		}				protected function generatePaletteMaps(colors:Array,positions:Array):Object {			var a:Array = [];			var r:Array = [];			var g:Array = [];			var b:Array = [];						var index:uint = 0;			var pos:uint = 0;			var prevPos:uint=0			var nextPos:uint = 0;			var a1:uint = 0;			var r1:uint = 0;			var g1:uint = 0;			var b1:uint = 0;			var a2:uint = 0;			var r2:uint = 0;			var g2:uint = 0;			var b2:uint = 0;						if (positions[index] == 0) {				a2 = colors[index]>>>24;				r2 = colors[index]>>16&0xFF;				g2 = colors[index]>>8&0xFF;				b2 = colors[index]&0xFF;				index = 1;			}						while (pos < 256) {				if (pos == nextPos) {					a1 = a2;					r1 = r2;					g1 = g2;					b1 = b2;					prevPos = nextPos;					var color:uint=0;					if (positions.length <= index) {						nextPos = 256;					} else {						nextPos = positions[index];						color = colors[index];					}					a2 = color>>>24&0xFF;					r2 = color>>16&0xFF;					g2 = color>>8&0xFF;					b2 = color&0xFF;					index++;				}				var ratio:Number = (pos-prevPos)/(nextPos-prevPos);				a[pos] = 0;//a1+(a2-a1)*ratio<<16;				// tag alpha onto red:				r[pos] = r1+(r2-r1)*ratio<<16 | a1+(a2-a1)*ratio<<24;				g[pos] = g1+(g2-g1)*ratio<<8;				b[pos] = b1+(b2-b1)*ratio<<0;				pos++;			}			return {r:r,g:g,b:b,a:a}		}			}	}