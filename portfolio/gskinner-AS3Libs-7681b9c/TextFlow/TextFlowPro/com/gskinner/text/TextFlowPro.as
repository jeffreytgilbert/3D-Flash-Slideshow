/*** GDS: list of known issues:* - orphans doesn't seem to be working properly.* - still some problems with setting the caret to the end of a line or on an empty line.* - caret draws at end of last textfield if there is an overflow.* - up/down arrow behaviour is (understandably) weird... paragraph at a time currently (because of nowrap).* - double click to select word doesn't work.**//*** TextFlow by Grant Skinner. Sep 9, 2007* Major revisions Jan 14, 2009* Visit www.gskinner.com/blog for documentation, updates and more free code.*** Copyright (c) 2007 Grant Skinner* * Permission is hereby granted, free of charge, to any person* obtaining a copy of this software and associated documentation* files (the "Software"), to deal in the Software without* restriction, including without limitation the rights to use,* copy, modify, merge, publish, distribute, sublicense, and/or sell* copies of the Software, and to permit persons to whom the* Software is furnished to do so, subject to the following* conditions:* * The above copyright notice and this permission notice shall be* included in all copies or substantial portions of the Software.* * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES* OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT* HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR* OTHER DEALINGS IN THE SOFTWARE.**/package com.gskinner.text {	import flash.display.Sprite;	import flash.display.LineScaleMode;	import flash.display.CapsStyle;	import flash.display.BlendMode;	import flash.events.Event;	import flash.events.FocusEvent;	import flash.events.KeyboardEvent;	import flash.events.MouseEvent;	import flash.geom.Point;	import flash.geom.Rectangle;	import flash.text.TextField;	import flash.text.TextFieldType;		import com.gskinner.text.TextFlowEntry;	public class TextFlowPro {		protected static var caret:Sprite; // the caret clip is shared between all TextFlowPro instances.		protected static var caretCount:uint=0; // used for blinking caret.				protected var ghost:TextField; // hidden field to enable copy/paste.		protected var dragProps:Object; // holds temporary props during a drag.		protected var entries:Array; // generic objects to store string info.		protected var _textFields:Array; // store textfield references (only used for getter/setter).		protected var _alwaysShowSelection:Boolean=false;		protected var _orphans:uint = 2; // end of field		protected var _widows:uint = 2; // top of field		protected var _type:String = TextFieldType.INPUT;				public function TextFlowPro(textFields:Array, text:String=null) {			if (caret == null) {				caret = new Sprite();				caret.graphics.lineStyle(1,0xFFFFFF,1,true,LineScaleMode.NONE,CapsStyle.NONE);				caret.graphics.lineTo(0,100);				caret.blendMode = BlendMode.DIFFERENCE;			}						entries = [];						ghost = new TextField();			ghost.text = (text == null) ? textFields[0].text : text;			ghost.addEventListener(FocusEvent.FOCUS_OUT,handleGhostEvent,false,0,true);			ghost.addEventListener(Event.CHANGE,handleGhostEvent,false,0,true);			ghost.addEventListener(KeyboardEvent.KEY_DOWN,handleGhostEvent,false,0,true);			ghost.alwaysShowSelection = _alwaysShowSelection;			ghost.type = _type;			ghost.multiline = true;			ghost.width = ghost.height = 0;			/*			// this can be handy for testing. You can see the ghost to the right of the screen.			ghost.width = 150;			ghost.x = 550;			ghost.height = 400;			ghost.wordWrap = true;			*/						this.textFields = textFields;		}				public function reflow():void {			if (entries.length == 0) { return; }						var l:uint = entries.length;			var lastIndex:Number = 0;			var sub:String;			var txt:String = ghost.text;						for (var i:uint=0; i<l; i++) {				var entry:TextFlowEntry = entries[i] as TextFlowEntry;				var fld:TextField = entry.textField;				entry.endIndex = entry.beginIndex = lastIndex;				entry.trim = 0;				fld.text = "";								if (lastIndex >= txt.length) { continue; }								sub = txt.substr(lastIndex);				if (i > 0) {					fld.text = ltrim(sub);					var trim:uint = sub.length-fld.text.length;					lastIndex += trim;					entry.beginIndex = lastIndex;					(entries[i-1] as TextFlowEntry).trim += trim;				} else {					fld.text = sub;				}								// find end:				fld.scrollV = 0;								var nextLineIndex:uint = fld.bottomScrollV;								// use try/catch to find when we've reached the end of our text (maxScrollV is unreliable):				try {					var offset:uint = fld.getLineOffset(nextLineIndex);				} catch (e:*) {					entry.endIndex = lastIndex = txt.length;					continue;				}								if (_orphans > 1 && _widows > 1) {					// find start and end line index of last paragraph in field:					var pbegin:int = fld.getLineIndexOfChar(fld.getFirstCharInParagraph(offset));					var pend:int = fld.getLineIndexOfChar(fld.getFirstCharInParagraph(offset)+fld.getParagraphLength(offset));					// check if the paragraph straddles the field break:					if (pend > nextLineIndex && pbegin < nextLineIndex) {						if ((nextLineIndex-pbegin) < _orphans) { offset = fld.getFirstCharInParagraph(offset); }						else if ((pend-nextLineIndex) < _widows) { offset = fld.getLineOffset(pend-_widows); } // need to grab at least widows lines, +1 gets rid of leading space					}				}								sub = fld.text.substr(0,offset)				fld.text = rtrim(sub);				entry.trim = sub.length-fld.text.length;								lastIndex += fld.text.length;				entry.endIndex = lastIndex;				lastIndex += entry.trim;			}			lastIndex = 0;			setSelection(ghost.selectionBeginIndex,ghost.selectionEndIndex);		}				public function clearSelection():void {			for (var i:int=0; i<entries.length; i++) {				var fld:TextField = (entries[i] as TextFlowEntry).textField;				fld.setSelection(0,0);			}			ghost.setSelection(0,0);			if (caret.parent != null) { caret.parent.removeChild(caret); }			if (ghost.stage.focus == ghost) { ghost.stage.focus = null; }		}				public function setSelection(beginIndex:uint, endIndex:uint):void {			var beginFldObj:Object = getThreadIndex(beginIndex);			var endFldObj:Object = getThreadIndex(endIndex);			setThreadSelection(beginFldObj.fieldIndex,beginFldObj.index,endFldObj.fieldIndex,endFldObj.index);			ghost.setSelection(beginIndex,endIndex);		}				public function getOverflow(textFieldIndex:int=-1, ltrimString:Boolean=true):String {			if (textFieldIndex < 0) { textFieldIndex = entries.length+textFieldIndex; }			var str:String = ghost.text.substr((entries[textFieldIndex] as TextFlowEntry).endIndex);			return (ltrimString) ? ltrim(str) : str;		}					// public getter / setters:		public function set alwaysShowSelection(value:Boolean):void {			if (ghost != null) { ghost.alwaysShowSelection = value; }			_alwaysShowSelection = value;		}		public function get alwaysShowSelection():Boolean {			return _alwaysShowSelection;		}				public function set type(value:String):void {			if (ghost != null) { ghost.type = value; }			_type = value;		}		public function get type():String {			return _type;		}				public function get text():String {			return ghost.text;		}		public function set text(value:String):void {			ghost.text = value;			reflow();		}				public function get selectionBeginIndex():int {			return ghost.selectionBeginIndex;		}				public function get selectionEndIndex():int {			return ghost.selectionEndIndex;		}				public function set orphans(value:uint):void {			_orphans = value;			reflow();		}		public function get orphans():uint {			return _orphans;		}				public function set widows(value:uint):void {			_widows = value;			reflow();		}		public function get widows():uint {			return _widows;		}				public function set tabIndex(value:int):void {			ghost.tabIndex = value;		}		public function get tabIndex():int {			return ghost.tabIndex;		}				public function set textFields(value:Array):void {			var fld:TextField;						// clean up old textfields, and restore them to their original state:			while (entries.length > 0) {				var entry:TextFlowEntry = entries.pop() as TextFlowEntry;				fld = entry.textField;				fld.removeEventListener(MouseEvent.MOUSE_DOWN,handleThreadEvent);				fld.alwaysShowSelection = entry.alwaysShowSelection;				fld.selectable = entry.selectable;				fld.type = entry.type;			}			_textFields = [];						// set up new fields:			for (var i:int=0; i<value.length; i++) {				fld = value[i] as TextField;				if (fld == null) { continue; }								_textFields.push(fld);				entries.push(new TextFlowEntry(fld));								// set up field for threading:				fld.addEventListener(MouseEvent.MOUSE_DOWN,handleThreadEvent,false,0,true);				fld.alwaysShowSelection = true;				fld.selectable = false;				fld.type = TextFieldType.DYNAMIC;			}						// add the ghost to the parent of the first textField:			if (ghost.stage == null && entries.length > 0) {				_textFields[0].stage.addChild(ghost);				ghost.stage.addEventListener(FocusEvent.KEY_FOCUS_CHANGE,handleGhostEvent,false,0,true);			}						reflow();		}		public function get textFields():Array {			return _textFields;		}			// protected methods:		protected function handleThreadEvent(evt:MouseEvent):void {			var targetFld:TextField = evt.target as TextField;						if (evt.type == MouseEvent.MOUSE_DOWN) {				// start watching for a drag operation:				ghost.stage.addEventListener(MouseEvent.MOUSE_MOVE,handleThreadEvent,false,0,true);				ghost.stage.addEventListener(MouseEvent.MOUSE_UP,handleThreadEvent,false,0,true);								// figure out where the press happened:				var index:uint = getCharIndexAtPoint(targetFld,new Point(evt.localX,evt.localY));				var fldIndex:uint = getFieldIndex(targetFld);								if (evt.shiftKey) {					// make the selection, and prep for the drag:					var threadIndex:Object = getThreadIndex(ghost.selectionBeginIndex);					dragProps={fld:entries[threadIndex.fieldIndex].textField,fldIndex:threadIndex.fieldIndex,selectionIndex:threadIndex.index};					setThreadSelection(threadIndex.fieldIndex,threadIndex.index,fldIndex,index);				} else {					// set the caret, and prep for the drag:					dragProps = {fld:targetFld,fldIndex:getFieldIndex(targetFld),selectionIndex:index};					setThreadSelection(fldIndex,index,fldIndex,index);				}							} else if (evt.type == MouseEvent.MOUSE_UP) {				// drag ended:				ghost.stage.removeEventListener(MouseEvent.MOUSE_MOVE,handleThreadEvent);				ghost.stage.removeEventListener(MouseEvent.MOUSE_UP,handleThreadEvent);							} else if (evt.type == MouseEvent.MOUSE_MOVE) {				// drag moved:				var selectionIndex:int = -1;				var fld:TextField;								// start from last fld and move backwards, trying to find furthest selection:				for (var i:int = entries.length-1; i>=0; i--) {					fld = (entries[i] as TextFlowEntry).textField;					if (fld.mouseX > 0 && fld.mouseY > 0) {						selectionIndex = getCharIndexAtPoint(fld,new Point(fld.mouseX,fld.mouseY));						setThreadSelection(dragProps.fldIndex,dragProps.selectionIndex,i,selectionIndex);						evt.updateAfterEvent();						break;					}				}								if (selectionIndex == -1) {					// we dragged up or left of all fields. Find the point relative to the first field:					var lineIndex:int = Math.max(0,fld.getLineIndexAtPoint(2,Math.min(fld.height-2,fld.mouseY)));					selectionIndex = Math.max(0,fld.getLineOffset(lineIndex));					setThreadSelection(dragProps.fldIndex,dragProps.selectionIndex,0,selectionIndex);				}			}		}				protected function setThreadSelection(beginTextFieldIndex:uint,beginCharacterIndex:uint,endTextFieldIndex:uint,endCharacterIndex:uint):void {			clearSelection();			ghost.stage.focus = ghost;						if (beginTextFieldIndex == endTextFieldIndex && beginCharacterIndex == endCharacterIndex) {				setThreadCaret(beginTextFieldIndex,beginCharacterIndex);				return;			}						// swap field and character indexes if the fields are in the wrong order (to allow reverse selections):			if (beginTextFieldIndex > endTextFieldIndex) {				var tmp:uint = endTextFieldIndex;				endTextFieldIndex = beginTextFieldIndex;				beginTextFieldIndex = tmp;				tmp = endCharacterIndex;				endCharacterIndex = beginCharacterIndex;				beginCharacterIndex = tmp;			}						var beginFld:TextField = (entries[beginTextFieldIndex] as TextFlowEntry).textField;			var endFld:TextField = (entries[endTextFieldIndex] as TextFlowEntry).textField;						if (beginTextFieldIndex == endTextFieldIndex) {				// single field selection.				beginFld.setSelection(beginCharacterIndex, endCharacterIndex );			} else {				// multi field selection.				beginFld.setSelection( beginCharacterIndex, beginFld.text.length );				endFld.setSelection( 0, endCharacterIndex );				for (var i:int=beginTextFieldIndex+1; i<endTextFieldIndex; i++) {					var fld:TextField = (entries[i] as TextFlowEntry).textField;					fld.setSelection(0,fld.text.length);				}			}						// set the ghost selection:			ghost.setSelection(getGhostIndex(beginTextFieldIndex,beginCharacterIndex) , getGhostIndex(endTextFieldIndex,endCharacterIndex));		}				protected function setThreadCaret(textFieldIndex:uint,characterIndex:int):void {			var ghostIndex:uint = getGhostIndex(textFieldIndex,characterIndex);			ghost.setSelection(ghostIndex,ghostIndex);			if (ghost.stage.focus != ghost) { return; }						var fld:TextField = (entries[textFieldIndex] as TextFlowEntry).textField;			var charBounds:Rectangle = fld.getCharBoundaries(characterIndex);			var widthMult:Number=0;						// deal with carriage returns (they return null charBounds):			while (charBounds == null && characterIndex >= 0) {				charBounds = fld.getCharBoundaries(--characterIndex);				widthMult = 1;			}						if (charBounds == null) {				trace("Error occurred. Unable to get character bounds for character ("+characterIndex+ ") of textField ("+textFieldIndex+")");			}						// need to use matrix values to get around a bug with text fields created in authoring:			caret.x = fld.transform.matrix.tx+charBounds.x+charBounds.width*widthMult;			caret.y = fld.transform.matrix.ty+charBounds.y;			caret.height = charBounds.height;			caret.addEventListener(Event.ENTER_FRAME,handleCaretEvent);			fld.parent.addChildAt(caret,fld.parent.getChildIndex(fld)+1);		}				protected function handleGhostEvent(evt:Event):void {			if (evt.type == FocusEvent.FOCUS_OUT) {				if (!_alwaysShowSelection) { clearSelection(); }			} else if (evt.type == FocusEvent.KEY_FOCUS_CHANGE) {				if ((evt as FocusEvent).relatedObject == ghost) {					// select all:					setSelection(0,ghost.text.length);				}			} else if (evt.type == Event.CHANGE) {				text = ghost.text;			} else if (evt.type == KeyboardEvent.KEY_DOWN) {				var keyCode:uint = (evt as KeyboardEvent).keyCode;				// only worry about nav keys and cmd/ctrl-a				if ((keyCode >= 33 && keyCode <= 40) || (keyCode==65 && (evt as KeyboardEvent).ctrlKey)) {					ghost.addEventListener(Event.ENTER_FRAME,handleGhostEvent,false,0,true);					// reset caret blinking, so it doesn't disappear while using arrow keys.					caretCount = 0;				}			} else if (evt.type == Event.ENTER_FRAME) {				ghost.removeEventListener(Event.ENTER_FRAME,handleGhostEvent);				setSelection(ghost.selectionBeginIndex,ghost.selectionEndIndex);			}		}				protected function handleCaretEvent(evt:Event):void {			caretCount++;			// blink 3 times per second:			if (caretCount == Math.ceil(ghost.stage.frameRate/3)) {				caret.visible = !caret.visible;				caretCount = 0;			}		}						protected function getGhostIndex(textFieldIndex:uint,characterIndex:uint):uint {			return (textFieldIndex > 0) ? characterIndex+entries[textFieldIndex-1].endIndex : characterIndex;		}				protected function getThreadIndex(index:uint):Object {			for (var i:uint=0; i<entries.length; i++) {				var entry:TextFlowEntry = (entries[i] as TextFlowEntry);				if (entry.endIndex+entry.trim >= index) {					return {fieldIndex:i,index:index-entry.beginIndex};				}			}			return {fieldIndex:entries.length-1,index:(entries[entries.length-1] as TextFlowEntry).endIndex};		}				protected function getCharIndexAtPoint(textField:TextField,point:Point):uint {			var index:int = textField.getCharIndexAtPoint(point.x,point.y);			if (index > -1) { return index; }			var lineIndex:int = Math.max(0,textField.getLineIndexAtPoint(2,Math.min(textField.height-2,point.y)));			if (lineIndex == 0 && point.y > textField.height-4) { lineIndex = textField.bottomScrollV-1; }			index = Math.min(textField.text.length,textField.getLineOffset(lineIndex)+textField.getLineLength(lineIndex));			return index;		}				protected function getFieldIndex(textField:TextField):int {			for (var i:uint=0;i<entries.length;i++) {				if ((entries[i] as TextFlowEntry).textField == textField) { return i; }			}			return -1;		}				// standard rtrim:		// trims trailing lines and white space		protected function rtrim(string:String):String {			return string.replace(/[\n\r]+\s*$/,'');		}				// ltrim that strips leading empty lines, but leaves leading whitespace:		protected function ltrim(string:String):String {			return string.replace(/^\s*[\n\r]/, '');		}					}}