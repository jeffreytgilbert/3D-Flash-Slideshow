package  {		import flash.display.MovieClip;	import flash.display.Shape;	import flash.display.Sprite;	import flash.display.BitmapData;	import flash.display.Shader;	import flash.geom.PerspectiveProjection;	import flash.geom.Point;	import flash.display.Bitmap;	import flash.display.StageScaleMode;	import flash.display.StageAlign;	import flash.events.Event;	import com.greensock.TweenLite;	import flash.text.TextField;	import flash.events.MouseEvent;	import flash.display.SimpleButton;		public class CarouselWall extends MovieClip {				var facets:Array = [];		var facetContainers:Array = [];		var labels:Array = [];		var carousel:Sprite = new Sprite();		var pp:PerspectiveProjection = new PerspectiveProjection();				// Thumbnail size		private var w:Number = 300;		private var h:Number = 200; // height		private var columns_per_row:uint = 50;				// A + B + C = 180º		// a/sin(A) = b/sin(B) = c/sin(C)		// a² = b² + c² - 2*b*c * cos(A)		// b² = a² + c² - 2*a*c * cos(B)		// c² = b² + a² - 2*b*a * cos(C)	   		private var a:Number, b:Number, c:Number;		private var A:Number, B:Number, C:Number;				private var total:uint;				private var addButton:SimpleButton = new SimpleButton();		private var removeButton:SimpleButton = new SimpleButton();				public function CarouselWall() {			stage.scaleMode = StageScaleMode.NO_SCALE;			stage.align = StageAlign.TOP_LEFT;			stage.addEventListener(Event.RESIZE, resizeHandler);//			carousel.z=600;			pp.projectionCenter = new Point((stage.stageWidth/2),(stage.stageHeight/2));			this.transform.perspectiveProjection = pp;						// constructor code			var i:uint = 0;			var preloaded_total = 200;			b = w; // base = thumb width			// center carousel			carousel.x = (stage.stageWidth/2);			carousel.y = (stage.stageHeight/2);						addChild(carousel);						while(i<preloaded_total){				addItemToCarousel();				i++;			}						var addTxt:TextField = new TextField();			addTxt.text='add';			addTxt.textColor=0x009900;			addTxt.x=addTxt.textWidth/2;			addTxt.y=addTxt.textHeight/2;						var addHitArea:Sprite = new Sprite();			addHitArea.graphics.beginFill(0xCCFFCC);			addHitArea.graphics.drawRect(0,0,100,50);			addHitArea.graphics.endFill();			addHitArea.addChild(addTxt);			addButton.upState = addHitArea;			addButton.overState = addHitArea;			addButton.hitTestState = addHitArea;			addChild(addButton);						var removeTxt:TextField = new TextField();			removeTxt.text='remove';			removeTxt.textColor=0x990000;			removeTxt.x=addTxt.textWidth/2;			removeTxt.y=addTxt.textHeight/2;						var removeHitArea:Sprite = new Sprite();			removeHitArea.graphics.beginFill(0xFFCCCC);			removeHitArea.graphics.drawRect(0,0,100,50);			removeHitArea.graphics.endFill();			removeHitArea.addChild(removeTxt);			removeButton.upState = removeHitArea;			removeButton.overState = removeHitArea;			removeButton.hitTestState = removeHitArea;						removeButton.x = stage.stageWidth - removeButton.width;			addChild(removeButton);						addButton.addEventListener(MouseEvent.CLICK,function(evt:MouseEvent):void{				addItemToCarousel();				updateDisplayList();			});						removeButton.addEventListener(MouseEvent.CLICK,function(evt:MouseEvent):void{				removeItemFromCarousel();				updateDisplayList();			});						updateDisplayList();			spin();		}				private function addItemToCarousel(evt:Event=null):void{			facets[total] = new Shape();			facetContainers[total] = new Sprite();			labels[total] = new TextField();						// get married			facetContainers[total].addChild( facets[total] );			// have children			carousel.addChild(facetContainers[total]);			// name them			facetContainers[total].addChild(labels[total]);						facets[total].x = -(b/2); // center the facet inside the container			facets[total].y = 0;			facets[total].z = 0;			facets[total].graphics.clear();			facets[total].graphics.beginFill(0xCCCCFF);			facets[total].graphics.drawRect(0,0,b,h);			facets[total].graphics.endFill();			facets[total].alpha=.5;			(labels[total] as TextField).textColor=0x0;			labels[total].text = '#'+total;//			labels[total].y = total*10;						total++;		}				private function removeItemFromCarousel(evt:Event=null):void{			if(total<=0) return;			total--;			carousel.removeChild(facetContainers[total]);			facetContainers[total].removeChild( labels[total] );			facetContainers[total].removeChild( facets[total] );						delete facets[total];			delete facetContainers[total];			delete labels[total];		}				private function updateDisplayList():void{			var total_items_per_row:uint = (total>columns_per_row?columns_per_row:total);			var i:uint = 0;			var vertex:Number = 360 / total_items_per_row;			var circumference = b * total_items_per_row; // area = thumb width * total thumbs			var radius:Number = circumference / (2 * Math.PI); // circle area formula solving for radius (a = 2 pi r)			trace('radius',radius);			trace('vertex',vertex);			carousel.z=-(radius * 19/20);						// isosceles triangle rules			a = c = radius; // length of legs			A = C = (180 - vertex)/2; // angles in degrees			B = vertex; // angle of vertex in degrees			//			b = Math.sqrt( (a^2) + (c^2) - (2*a*c*Math.cos(B)) ); // if no width, but given radius instead						var currentAngleInRadians:Number;			var row:uint = 0;			// number of rows times thumb height divided in half to center it			var yOffset:Number = ((total / columns_per_row) * h) / 2;						while(i < total){				row = i / columns_per_row;//				col = i % columns_per_row;								currentAngleInRadians = degreesToRadians(vertex*i);				TweenLite.to(facetContainers[i],1,{					y:(row * h) - yOffset, // this needs to center itself					x:radius * Math.sin(currentAngleInRadians),					z:radius * Math.cos(currentAngleInRadians),					rotationY: 360 * (i/total_items_per_row) // some math here could be precalculated				});								i++;			}//			updateRotation();		}				private function degreesToRadians(degrees:Number):Number{			return degrees*(Math.PI/180);		}				private function radiansToDegrees(radians:Number):Number{			return radians*(180/Math.PI);		}				private function spin():void{			TweenLite.to(carousel,10,{				rotationY:360, onComplete:function():void{					carousel.rotationY = 0;					spin();				}			});		}/*				private function updateRotation():void{			var i:uint = 0;			while(i<total){				facetContainers[i].rotationY = 360 * (i/total);				i++;			}		}*/				private function resizeHandler(evt:Event=null):void{			carousel.x = (stage.stageWidth/2);			carousel.y = (stage.stageHeight/2);			removeButton.x = stage.stageWidth - removeButton.width;			pp.projectionCenter = new Point((stage.stageWidth/2),(stage.stageHeight/2));			this.transform.perspectiveProjection = pp;		}	}}