package  {	import flash.display.Shape;	import flash.display.Bitmap;	import flash.display.PixelSnapping;	import flash.display.BitmapData;	import flash.geom.Matrix;	import flash.geom.Rectangle;	import flash.display.Loader;	import flash.events.IOErrorEvent;	import flash.events.Event;	import flash.events.ProgressEvent;	import flash.net.URLRequest;	import flash.events.EventDispatcher;	import flash.filters.BitmapFilter;		public class BitmapUtils extends EventDispatcher {				public static const IMAGE_LOADED_OK:String = 'imageLoadedOk';		public static const IMAGE_LOADED_ERROR:String = 'imageLoadedError';				public static function loadImage(url:String, successCallback:Function=null, errorCallback:Function=null, progressCallback:Function=null):Loader{			// Set properties on my Loader object			var imageLoader:Loader = new Loader();			trace('Trying to load '+url);			if(progressCallback === null){ progressCallback = progressHandler; }			if(successCallback === null){ successCallback = successHandler; }			if(errorCallback === null){ errorCallback = errorHandler; }			imageLoader.contentLoaderInfo.addEventListener(ProgressEvent.PROGRESS, progressCallback, false,0,true);			imageLoader.contentLoaderInfo.addEventListener(Event.COMPLETE, successCallback, false,0,true);			imageLoader.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR, errorCallback, false,0,true);			imageLoader.contentLoaderInfo.addEventListener(IOErrorEvent.NETWORK_ERROR, errorCallback, false,0,true);			imageLoader.contentLoaderInfo.addEventListener(IOErrorEvent.DISK_ERROR, errorCallback, false,0,true);			imageLoader.contentLoaderInfo.addEventListener(IOErrorEvent.VERIFY_ERROR, errorCallback, false,0,true);			imageLoader.load(new URLRequest(url));			return imageLoader;		}				public static function progressHandler(evt:ProgressEvent):void{			// trace(evt.bytesLoaded+' of '+evt.bytesTotal);			evt.stopPropagation();		}		public static function successHandler(evt:Event):void{ 			trace('Image ok'); 			evt.stopPropagation();		}		public static function errorHandler(evt:IOErrorEvent):void{ 			trace('Image failed to load: '+evt.type+' '+(evt.currentTarget as Loader).loaderInfo.loaderURL);			evt.stopPropagation();		}				public static function colorToRoundedBoxShape(color:uint, _width, _height, ellipseWidth, ellipseHeight, shape:Shape):Shape{			shape.graphics.clear();			shape.graphics.beginFill(color);			shape.graphics.drawRoundRect(0, 0, _width, _height, ellipseWidth, ellipseHeight);			shape.graphics.endFill();			return shape;		}				public static function colorToShape(color:uint,shape:Shape, _width:Number=1, _height:Number=1):Shape{			shape.graphics.clear();			shape.graphics.beginFill(color);			shape.graphics.drawRect(0, 0, _width, _height);			shape.graphics.endFill();			return shape;		}				public static function bitmapToShape(bitmap:Bitmap,shape:Shape):Shape{//			if(!bitmap || !bitmap.bitmapData) return shape;			shape.graphics.clear();			shape.graphics.beginBitmapFill(bitmap.bitmapData, null, false, true);			shape.graphics.drawRect(0, 0, bitmap.width, bitmap.height);			shape.graphics.endFill();			shape.alpha = 0;			return shape;		}		public static function crop(bitmapToCrop:Bitmap, _x:Number, _y:Number, _width:Number, _height:Number):Bitmap{			var cropArea:Rectangle = new Rectangle( 0, 0, _width, _height );			var croppedBitmap:Bitmap = new Bitmap( new BitmapData( _width, _height ), PixelSnapping.ALWAYS, true );			croppedBitmap.bitmapData.draw(bitmapToCrop, new Matrix(1, 0, 0, 1, -_x, -_y) , null, null, cropArea, true );			return croppedBitmap;		}		public static function randomizeArray(array:Array):Array {			var newArray:Array = new Array();			while(array.length > 0){				var obj:Array = array.splice(Math.floor(Math.random()*array.length), 1);				newArray.push(obj[0]);			}			return newArray;		}		/**		 * Compute the largest bounding box for a MovieClip that has several filters applied.		 * @param	pDORect		 * @param	pFilters		 * @return		 */		public static function getBoundingBox( pDORect:Rectangle, pFilters:Array ):Rectangle{			// Get the first filter and compute his bounding box			var filter:BitmapFilter = pFilters[ 0 ];			if (filter == null ) throw new TypeError( "The filters Array must contains at least one filter" );						var b:BitmapData = new BitmapData( pDORect.width, pDORect.height, false );			var r:Rectangle  = b.generateFilterRect( pDORect, filter );			b.dispose();									// Helps to find the largest bounding box 			var le:Number = r.left;			var to:Number = r.top;			var ri:Number = r.right;			var bo:Number = r.bottom;									// How many filters have been applied to the MovieClip ?			var ln:int = pFilters.length;						for (var i:int = 1; i < ln ; i++){				b              = new BitmapData( r.width, r.height, false );				filter         = pFilters[ i ];								// Find the next flash.geom.Rectangle object starting with the one we find in the previous iteration				r               = b.generateFilterRect( r, filter ); 								// Release the memory used. 				// Notice that this BitmapData object is only necessary for computing the filtered bounding box				b.dispose();								// If the size of new Rectangle is larger that the previous one, we update the values for the bounding box				if ( r.left   < le ) le = r.left; 				if ( r.top    < to ) to = r.top; 				if ( r.right  > ri ) ri = r.right; 				if ( r.bottom > bo ) bo = r.bottom; 			}						b = null;						// Return the Rectangle object that corresponds to the largest bounding box			r = new Rectangle();			r.left   = le;			r.top    = to;			r.right  = ri;			r.bottom = bo;						return r;		}		public function BitmapUtils() {			// constructor code		}	}}