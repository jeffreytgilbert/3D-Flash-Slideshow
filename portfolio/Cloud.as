package{	import flash.display.*;	import flash.geom.Point;	import flash.events.Event;	import flash.filters.DisplacementMapFilterMode;	import flash.filters.DisplacementMapFilter;	import flash.geom.Matrix;		public class Cloud extends MovieClip	{		private var _angle:Number=0;		private var _offset:Number=0;		private var _point:Point;		private var _gradientShape:Shape = new Shape();		private var _cloudBitmapData:BitmapData; // = new BitmapData(1, 1, true, 0x000000);		private var _noiseBitmapData:BitmapData; // = new BitmapData(1, 1, true, 0x000000);		private var _cloudBitmap:Bitmap; // = new Bitmap();				public function Cloud(){			addEventListener(Event.ADDED_TO_STAGE, addedToStageHandler);			trace('init');		}				private function addedToStageHandler(evt:Event):void{			// If these bd's exist, clear the memory for them before creating new bds			if(_noiseBitmapData){ _noiseBitmapData.dispose(); }			if(_cloudBitmapData){ _cloudBitmapData.dispose(); }			_noiseBitmapData = new BitmapData(stage.stageWidth, stage.stageHeight, true, 0x000000);			_cloudBitmapData = new BitmapData(stage.stageWidth, stage.stageHeight, true, 0x000000);					var g:Graphics = _gradientShape.graphics;			g.clear(); // clear any existing graphics (none)						var m:Matrix = new Matrix(); // initialize a transformation matrix			m.createGradientBox(stage.stageWidth, stage.stageHeight, 0, 0, 0); // stretch the gradient to fit the app window			// define the fill color (radial gradient) to be used in coloring the clouds			g.beginGradientFill(GradientType.RADIAL, [ // colors				0xDDDDDF,				0xFAFBFA,				0xFF0000, // white				0xbeddf2			], [ // alphas				.4,1,.6,.8			], [ // ratios				0, 				100,				127,				255			], m, SpreadMethod.PAD, InterpolationMethod.RGB);//			g.beginGradientFill("radial", [0x444645, 0x0A0A0A], [50, 90], [0, 0xFF], m, "pad", "RGB", 0);			// draw the fill into the rectangle			g.drawRect(0, 0, stage.stageWidth, stage.stageHeight);			// end the fill drawing			g.endFill();						// display the shape on the screen			addChild(_gradientShape);						/*			fill.angle = 90;			*/			_cloudBitmapData.draw(_gradientShape);						_cloudBitmap = new Bitmap();			_cloudBitmap.blendMode = BlendMode.SCREEN; // define this bitmap as one that inverts the color of something it's applied to. Normal displays it normally			_cloudBitmap.smoothing = true;			_cloudBitmap.bitmapData = _cloudBitmapData;			_cloudBitmap.x = 0;			_cloudBitmap.y = 0;			_cloudBitmap.width = stage.stageWidth;			_cloudBitmap.height = stage.stageHeight;//			addChild(_cloudBitmap);						trace('added');			addEventListener(Event.ENTER_FRAME, enterFrameHandler);						trace(BitmapDataChannel.ALPHA);			trace(BitmapDataChannel.BLUE);			trace(BitmapDataChannel.GREEN);			trace(BitmapDataChannel.RED);			trace(BitmapDataChannel.ALPHA | BitmapDataChannel.BLUE | BitmapDataChannel.GREEN | BitmapDataChannel.RED);		}				private function removedFromStageHandler(evt:Event):void{			trace('removed');			removeEventListener(Event.ENTER_FRAME, enterFrameHandler);			removeChild(_cloudBitmap);		}				private function enterFrameHandler(evt:Event):void{			trace('eframe');						_point = new Point(_offset, 0);/*						_bitmap.perlinNoise(300, 100, 2, 1000, 								false, true, BitmapDataChannel.ALPHA, 								false, [_point, _point]);				<ns:Fire delay="{30}"			   detail="{2}"			   colors="{[0xFAFBFA, 0xbeddf2]}"			   width="{600}"			   height="{2000}"			   xSpeed="{2}"			   ySpeed="{0}"			   wFactor="{2}"			   hFactor="{19}" />			         noiseBitmap.perlinNoise(input.width / wFactor, input.height / hFactor, _octaves, Math.random(),                              true, false, 7, true, a);      var d:DisplacementMapFilter = new DisplacementMapFilter(noiseBitmap, new Point(0, 0), 1, 2, displacementScaleX,                                                              displacementScaleY, DisplacementMapFilterMode.                                                              IGNORE);      fire.draw(input);      fire.applyFilter(fire, fire.rect, new Point(0, 0), d);      //Now just drop the resulting bitmapData intop our output Bitmap and we're all done!       output.bitmapData = fire;			// output is a bitmap    // fire is a bitmap data // noise is a bitmap data*/					// create noise			_noiseBitmapData.perlinNoise(600/2, 2000/19, 2, Math.random(), 								true, false, 7, 								true, [_point,_point]);						// create a filter for the noise 			var d:DisplacementMapFilter = new DisplacementMapFilter(_noiseBitmapData, // bitmap to use 																	new Point(0,0), // x,y starting point (or is it offset)																	1,2,																	//BitmapDataChannel.GREEN, BitmapDataChannel.RED, 																	50, 50, // scale x, scale y																	DisplacementMapFilterMode.IGNORE);						// draw colored gradient into cloud bitmap data			_cloudBitmapData.draw(_gradientShape);						// apply displacement filter for perlin cloud noise			_cloudBitmapData.applyFilter(_cloudBitmapData, _cloudBitmapData.rect, new Point(0, 0), d);						// apply to bitmap 			_cloudBitmap.bitmapData = _cloudBitmapData;						_offset+=2;		}	}}